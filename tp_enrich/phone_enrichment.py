# =========================\n# PHASE 2: PHONE WATERFALL\n# Google -> Yelp -> Website scrape -> Apollo (secondary)\n# =========================\n\nimport os\nimport re\nimport json\nimport requests\nfrom typing import Dict, Optional\nfrom .logging_utils import setup_logger\n\nlogger = setup_logger(__name__)\n\n# -------------------------\n# Helpers: phone normalize\n# -------------------------\nPHONE_RE = re.compile(r"""\n    (?:\n      (?:\\+?1[\\s\\-\\.]?)?            # optional country code\n      (?:\\(?\\d{3}\\)?[\\s\\-\\.]?)      # area\n      \\d{3}[\\s\\-\\.]?\\d{4}           # local\n    )\n""", re.VERBOSE)\n\nTEL_RE = re.compile(r'tel:\\s*([+\\d][\\d\\-\\(\\)\\s\\.]{7,})', re.IGNORECASE)\n\ndef normalize_phone(raw: str) -> Optional[str]:\n    """Normalize phone to 10-digit US format."""\n    if not raw:\n        return None\n    s = raw.strip()\n    m = PHONE_RE.search(s)\n    if not m:\n        m = TEL_RE.search(s)\n        if not m:\n            return None\n        s = m.group(1)\n    digits = re.sub(r"\\D", "", s)\n    if len(digits) == 11 and digits.startswith("1"):\n        digits = digits[1:]\n    if len(digits) != 10:\n        return None\n    return digits  # store normalized 10-digit US phone\n\ndef format_phone(digits10: str) -> Optional[str]:\n    """Format 10-digit phone to (XXX) XXX-XXXX."""\n    if not digits10 or len(digits10) != 10:\n        return None\n    return f"({digits10[0:3]}) {digits10[3:6]}-{digits10[6:10]}"\n\ndef same_phone(a: Optional[str], b: Optional[str]) -> bool:\n    """Check if two phone numbers are the same after normalization."""\n    if not a or not b:\n        return False\n    return normalize_phone(a) == normalize_phone(b)\n\n# -------------------------\n# Yelp fetch (fallback/validate)\n# -------------------------\ndef yelp_search_phone(term: str, city: Optional[str] = None, state: Optional[str] = None, address: Optional[str] = None) -> Dict:\n    """\n    Returns: {"phone": "...", "source": "yelp", "confidence": "low/medium/high", "notes": "..."}\n    """\n    api_key = os.getenv("YELP_API_KEY") or os.getenv("YELP_KEY")\n    if not api_key:\n        logger.debug("Yelp: API key not set")\n        return {"phone": None, "source": "yelp", "confidence": "none", "notes": "YELP_API_KEY not set"}\n\n    headers = {"Authorization": f"Bearer {api_key}"}\n    url = "https://api.yelp.com/v3/businesses/search"\n\n    # Prefer a real location string; Yelp needs something.\n    location_parts = []\n    if city: location_parts.append(city)\n    if state: location_parts.append(state)\n    if not location_parts and address:\n        location_parts = [address]\n    location = ", ".join(location_parts) if location_parts else "United States"\n\n    params = {\n        "term": term,\n        "location": location,\n        "limit": 5,\n    }\n\n    try:\n        r = requests.get(url, headers=headers, params=params, timeout=12)\n        if r.status_code != 200:\n            logger.warning(f"Yelp search failed for '{term}': status={r.status_code}")\n            return {"phone": None, "source": "yelp", "confidence": "none", "notes": f"Yelp search status={r.status_code}"}\n        data = r.json()\n        biz = (data.get("businesses") or [])\n        if not biz:\n            logger.info(f"Yelp: no matches for '{term}'")\n            return {"phone": None, "source": "yelp", "confidence": "none", "notes": "No Yelp matches"}\n\n        # Pick best match by highest rating+review_count heuristic\n        biz_sorted = sorted(\n            biz,\n            key=lambda x: (x.get("review_count") or 0, x.get("rating") or 0),\n            reverse=True\n        )\n        top = biz_sorted[0]\n        # Need business details for phone\n        biz_id = top.get("id")\n        if not biz_id:\n            logger.warning(f"Yelp: no business id for '{term}'")\n            return {"phone": None, "source": "yelp", "confidence": "none", "notes": "No Yelp biz id"}\n\n        details_url = f"https://api.yelp.com/v3/businesses/{biz_id}"\n        d = requests.get(details_url, headers=headers, timeout=12)\n        if d.status_code != 200:\n            logger.warning(f"Yelp details failed for '{term}': status={d.status_code}")\n            return {"phone": None, "source": "yelp", "confidence": "none", "notes": f"Yelp details status={d.status_code}"}\n        det = d.json()\n        phone = det.get("display_phone") or det.get("phone")\n        norm = normalize_phone(phone)\n        if not norm:\n            logger.info(f"Yelp: no usable phone for '{term}'")\n            return {"phone": None, "source": "yelp", "confidence": "none", "notes": "Yelp returned no usable phone"}\n\n        formatted = format_phone(norm)\n        logger.info(f"Yelp: found phone '{formatted}' for '{term}'")\n        # Yelp-alone phone is "medium" at best. We'll bump to high only if it matches Google.\n        return {"phone": formatted, "source": "yelp", "confidence": "medium", "notes": "Yelp phone found"}\n    except Exception as e:\n        logger.error(f"Yelp error for '{term}': {repr(e)}")\n        return {"phone": None, "source": "yelp", "confidence": "none", "notes": f"Yelp error: {repr(e)}"}\n\n# -------------------------\n# Website scrape (fallback)\n# -------------------------\ndef scrape_phone_from_website(website_url: str) -> Dict:\n    """\n    Try to find a phone number from homepage HTML (tel: or visible phone patterns).\n    Returns {"phone": "...", "source": "website", "confidence": "...", "notes": "..."}\n    """\n    if not website_url:\n        return {"phone": None, "source": "website", "confidence": "none", "notes": "No website"}\n    try:\n        # Normalize URL\n        if not website_url.startswith("http"):\n            website_url = "https://" + website_url\n\n        headers = {"User-Agent": "Mozilla/5.0 (compatible; TP-Enrich/1.0)"}\n        r = requests.get(website_url, headers=headers, timeout=12, allow_redirects=True)\n        if r.status_code >= 400:\n            logger.warning(f"Website scrape failed for '{website_url}': status={r.status_code}")\n            return {"phone": None, "source": "website", "confidence": "none", "notes": f"Website status={r.status_code}"}\n\n        html = r.text or ""\n\n        # Prefer tel: links\n        tel = TEL_RE.search(html)\n        if tel:\n            norm = normalize_phone(tel.group(1))\n            if norm:\n                formatted = format_phone(norm)\n                logger.info(f"Website: found tel: link '{formatted}' on '{website_url}'")\n                return {"phone": formatted, "source": "website", "confidence": "medium", "notes": "Found tel: link"}\n\n        # Fallback: any phone pattern\n        m = PHONE_RE.search(html)\n        if m:\n            norm = normalize_phone(m.group(0))\n            if norm:\n                formatted = format_phone(norm)\n                logger.info(f"Website: found phone pattern '{formatted}' on '{website_url}'")\n                # Website scrape is less reliable (could be tracking/callrail)\n                return {"phone": formatted, "source": "website", "confidence": "low", "notes": "Found phone pattern in HTML"}\n\n        logger.info(f"Website: no phone found on '{website_url}'")\n        return {"phone": None, "source": "website", "confidence": "none", "notes": "No phone found on site"}\n    except Exception as e:\n        logger.error(f"Website scrape error for '{website_url}': {repr(e)}")\n        return {"phone": None, "source": "website", "confidence": "none", "notes": f"Website scrape error: {repr(e)}"}\n\n# -------------------------\n# Apollo org phone (secondary only)\n# -------------------------\ndef apollo_org_phone(domain: Optional[str], company_name: Optional[str]) -> Dict:\n    """\n    Apollo is a *secondary* phone source. Only trust if domain match is strong.\n    Requires APOLLO_API_KEY.\n    Returns {"phone": "...", "source":"apollo", "confidence":"low/medium", "notes":"..."}\n    """\n    api_key = os.getenv("APOLLO_API_KEY") or os.getenv("APOLLO_KEY")\n    if not api_key:\n        logger.debug("Apollo: API key not set")\n        return {"phone": None, "source": "apollo", "confidence": "none", "notes": "APOLLO_API_KEY not set"}\n\n    # If no domain, Apollo is too risky for phone matching\n    if not domain:\n        logger.debug("Apollo: no domain provided, skipping")\n        return {"phone": None, "source": "apollo", "confidence": "none", "notes": "No domain; skip Apollo phone"}\n\n    try:\n        url = "https://api.apollo.io/v1/organizations/search"\n        headers = {\n            "Content-Type": "application/json",\n            "Accept": "application/json",\n            "X-Api-Key": api_key,  # <-- REQUIRED BY APOLLO\n        }\n        payload = {\n            "q_organization_domains": domain,  # stronger than name-only\n            "page": 1\n        }\n        r = requests.post(url, headers=headers, json=payload, timeout=15)\n        if r.status_code != 200:\n            logger.warning(f"Apollo search failed for domain '{domain}': status={r.status_code}")\n            return {"phone": None, "source": "apollo", "confidence": "none", "notes": f"Apollo status={r.status_code}"}\n        data = r.json() or {}\n        orgs = data.get("organizations") or []\n        if not orgs:\n            logger.info(f"Apollo: no org match for domain '{domain}'")\n            return {"phone": None, "source": "apollo", "confidence": "none", "notes": "No Apollo org match"}\n\n        org = orgs[0]\n        phone = org.get("phone")\n        norm = normalize_phone(phone)\n        if not norm:\n            logger.info(f"Apollo: no usable phone for domain '{domain}'")\n            return {"phone": None, "source": "apollo", "confidence": "none", "notes": "Apollo returned no usable phone"}\n\n        formatted = format_phone(norm)\n        logger.info(f"Apollo: found phone '{formatted}' for domain '{domain}'")\n        # Apollo phone is still secondary; mark low unless corroborated elsewhere\n        return {"phone": formatted, "source": "apollo", "confidence": "low", "notes": "Apollo org phone found (domain matched)"}\n    except Exception as e:\n        logger.error(f"Apollo error for domain '{domain}': {repr(e)}")\n        return {"phone": None, "source": "apollo", "confidence": "none", "notes": f"Apollo error: {repr(e)}"}\n\n# -------------------------\n# PRIMARY PHONE SELECTION\n# -------------------------\ndef choose_primary_phone(\n    google_phone: Optional[str],\n    yelp_phone: Optional[str],\n    website_phone: Optional[str],\n    apollo_phone: Optional[str]\n) -> Dict:\n    """\n    Decision rules:\n      1) If Google exists => primary = Google\n         - confidence HIGH if Yelp matches\n         - else MEDIUM\n      2) Else if Yelp exists => primary = Yelp (MEDIUM)\n      3) Else if Website exists => primary = Website (LOW)\n      4) Else if Apollo exists => primary = Apollo (LOW)\n      5) Else none\n    """\n    if google_phone:\n        conf = "high" if (yelp_phone and same_phone(google_phone, yelp_phone)) else "medium"\n        notes = "Google primary" + ("; Yelp matched" if conf == "high" else "")\n        logger.info(f"Primary phone: Google '{google_phone}' (confidence: {conf})")\n        return {\n            "primary_phone": google_phone,\n            "primary_phone_source": "google",\n            "primary_phone_confidence": conf,\n            "enrichment_notes_phone": notes,\n            "secondary_phone_yelp": yelp_phone,\n            "secondary_phone_website": website_phone,\n            "secondary_phone_apollo": apollo_phone\n        }\n\n    if yelp_phone:\n        logger.info(f"Primary phone: Yelp '{yelp_phone}' (Google missing)")\n        return {\n            "primary_phone": yelp_phone,\n            "primary_phone_source": "yelp",\n            "primary_phone_confidence": "medium",\n            "enrichment_notes_phone": "Yelp primary (Google missing)",\n            "secondary_phone_yelp": yelp_phone,\n            "secondary_phone_website": website_phone,\n            "secondary_phone_apollo": apollo_phone\n        }\n\n    if website_phone:\n        logger.info(f"Primary phone: Website '{website_phone}' (Google/Yelp missing)")\n        return {\n            "primary_phone": website_phone,\n            "primary_phone_source": "website",\n            "primary_phone_confidence": "low",\n            "enrichment_notes_phone": "Website scraped phone (Google/Yelp missing)",\n            "secondary_phone_yelp": yelp_phone,\n            "secondary_phone_website": website_phone,\n            "secondary_phone_apollo": apollo_phone\n        }\n\n    if apollo_phone:\n        logger.info(f"Primary phone: Apollo '{apollo_phone}' (secondary source)")\n        return {\n            "primary_phone": apollo_phone,\n            "primary_phone_source": "apollo",\n            "primary_phone_confidence": "low",\n            "enrichment_notes_phone": "Apollo phone (secondary source; use caution)",\n            "secondary_phone_yelp": yelp_phone,\n            "secondary_phone_website": website_phone,\n            "secondary_phone_apollo": apollo_phone\n        }\n\n    logger.warning("No phone found from any source")\n    return {\n        "primary_phone": None,\n        "primary_phone_source": None,\n        "primary_phone_confidence": "none",\n        "enrichment_notes_phone": "No phone found",\n        "secondary_phone_yelp": None,\n        "secondary_phone_website": None,\n        "secondary_phone_apollo": None\n    }\n\n# -------------------------\n# MAIN WATERFALL FUNCTION\n# -------------------------\ndef enrich_business_phone_waterfall(biz_name: str, google_hit: Dict, domain: Optional[str]) -> Dict:\n    """\n    Phone enrichment waterfall: Google → Yelp → Website → Apollo\n\n    Args:\n        biz_name: Business name\n        google_hit: Google Places result dict with phone, address, city, state_region, website\n        domain: Extracted domain (if available)\n\n    Returns:\n        Dict with primary_phone, primary_phone_source, primary_phone_confidence,\n        enrichment_notes_phone, secondary phones, and all_phones_json\n    """\n    logger.info(f"========== PHONE WATERFALL START: '{biz_name}' ==========")\n\n    google_phone = google_hit.get("phone")\n    website_url = google_hit.get("website")\n\n    # Yelp uses city/state/address to reduce wrong matches\n    yelp = yelp_search_phone(\n        term=biz_name,\n        city=google_hit.get("city"),\n        state=google_hit.get("state_region"),\n        address=google_hit.get("address")\n    )\n    yelp_phone = yelp.get("phone")\n\n    site = scrape_phone_from_website(website_url) if website_url else {"phone": None, "notes": "No website"}\n    website_phone = site.get("phone")\n\n    ap = apollo_org_phone(domain=domain, company_name=biz_name)\n    apollo_phone = ap.get("phone")\n\n    decision = choose_primary_phone(\n        google_phone=google_phone,\n        yelp_phone=yelp_phone,\n        website_phone=website_phone,\n        apollo_phone=apollo_phone\n    )\n\n    # Keep a little structured debug info\n    decision["all_phones_json"] = json.dumps({\n        "google": google_phone,\n        "yelp": yelp_phone,\n        "website": website_phone,\n        "apollo": apollo_phone,\n        "yelp_notes": yelp.get("notes"),\n        "website_notes": site.get("notes") if isinstance(site, dict) else None,\n        "apollo_notes": ap.get("notes"),\n    }, ensure_ascii=False)\n\n    logger.info(f"========== PHONE WATERFALL END: primary={decision.get('primary_phone')} source={decision.get('primary_phone_source')} confidence={decision.get('primary_phone_confidence')} ==========")\n\n    return decision\n